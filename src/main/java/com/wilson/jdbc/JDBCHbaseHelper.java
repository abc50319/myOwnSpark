package com.wilson.jdbc;import com.wilson.conf.ConfigurationManager;import com.wilson.constant.Constants;import com.wilson.hbase.impl.HBaseServiceImpl;import com.wilson.util.ThreadPoolUtil;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.TableName;import org.apache.hadoop.hbase.client.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;/** * hbase操作这块全部采用JDBCHbaseHelper来执行 * 尤其是插入数据这块采用了MR的方法，性能比较高 */public class JDBCHbaseHelper {    // 第一步：在静态代码块中，直接加载Hbase相关配置    private static final Logger logger = LoggerFactory.getLogger(HBaseServiceImpl.class);    private ThreadPoolUtil threadPool= ThreadPoolUtil.init();       // 初始化线程池    private static Configuration hbaseconfig = null;    private static final int POOL_SIZE = 5;    private static final int TASK_COUNT = 10;    static {        Configuration conf = new Configuration();        conf.set("hbase.zookeeper.quorum",ConfigurationManager.getProperty(Constants.HBASE_ZOOKEEPER_QUORUM));        conf.set("hbase.zookeeper.property.clientPort",ConfigurationManager.getProperty(Constants.HBASE_ZOOKEEPER_PROPERTY_CLIENTPORT));        conf.set("hbase.rootdir",  ConfigurationManager.getProperty(Constants.HBASE_ROOTDIR));        hbaseconfig = HBaseConfiguration.create(conf);    }    public void batchPut(String tableName,final List<Put> puts) {        try {            run(hbaseconfig,tableName,puts);        } catch (Exception e) {            logger.error("batchPut failed . ", e);        }    }    public int run(Configuration hbaseconfig,String tableName,final List<Put> puts) throws InterruptedException, ExecutionException, TimeoutException {        /** a callback invoked when an asynchronous write fails. */        final BufferedMutator.ExceptionListener listener = new BufferedMutator.ExceptionListener() {            @Override            public void onException(RetriesExhaustedWithDetailsException e, BufferedMutator mutator) {                for (int i = 0; i < e.getNumExceptions(); i++) {                    System.out.println("Failed to sent put " + e.getRow(i) + ".");                }            }        };        BufferedMutatorParams params = new BufferedMutatorParams(                TableName.valueOf(tableName))                .listener(listener);        //        // step 1: create a single Connection and a BufferedMutator, shared by all worker threads.        //        try {            final Connection connection = ConnectionFactory.createConnection(hbaseconfig);            //BufferedMutator主要用来异步批量的将数据写入一个hbase表，就像Htable一样            final BufferedMutator mutator = connection.getBufferedMutator(params);            // ExecutorService是执行线程池            final ExecutorService workerPool = Executors.newFixedThreadPool(POOL_SIZE);            //Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。            // 可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程            List<Future<Void>> futures = new ArrayList<Future<Void>>(TASK_COUNT);            for (int i = 0; i < TASK_COUNT; i++) {                futures.add(workerPool.submit(new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        // step 2: each worker sends edits to the shared BufferedMutator instance. They all use                        // the same backing buffer, call-back "listener", and RPC executor pool.                        mutator.mutate(puts);                        mutator.flush();                        // do work... maybe you want to call mutator.flush() after many edits to ensure any of                        // this worker's edits are sent before exiting the Callable                        return null;                    }                }));            }            //            // step 3: clean up the worker pool, shut down.            //            for (Future<Void> f : futures) {                //get方法：获取计算结果（如果还没计算完，也是必须等待的）                f.get(10, TimeUnit.SECONDS);            }            int i=0;            for (Future<Void> f : futures) {                //get方法：获取计算结果（如果还没计算完，也是必须等待的）                if(f.isDone()){                    i++;                }            }            if(TASK_COUNT == i){                workerPool.shutdown();            }            //Thread.sleep(5000*10000);            //System.out.println("=====================OK=====================");        } catch (IOException e) {            // exception while creating/destroying Connection or BufferedMutator            e.printStackTrace();        } // BufferedMutator.close() ensures all work is flushed. Could be the custom listener is        // invoked from here.        return 0;    }}